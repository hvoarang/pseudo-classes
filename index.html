<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pseudo-classes</title>

    <!-- шрифты -->
    <!-- normolize -->
    <!-- stylesheet CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <link rel="stylesheet" href="/style/style.css" />
  </head>

  <body class="body">
    <div>
      <!-- ================= Структурные псевдоклассы ============ -->

      <h1>Структурные псевдоклассы</h1>
      <p>
        Структурные псевдоклассы это способ выбрать определённые элементы из
        коллекции дочерних элементов (соседей), без присваивания дополнительных
        классов. Дочерние элементы (соседи) - это элементы с общим родителем.
      </p>
      <ul class="list">
        <li class="list-item">
          <a class="list-link">Ссылка 1</a>
        </li>
        <li class="list-item">
          <a class="list-link">Ссылка 2</a>
        </li>
        <li class="list-item">
          <a class="list-link">Ссылка 3</a>
        </li>
      </ul>
      <p>
        В примере выше элементы li.list-item это соседи, и к ним можно будет
        применить структурные псевдоклассы. В тоже время ссылки a.list-link не
        являются соседями, у них нет общего родителя, поэтому нельзя будет
        использовать псевдоклассы для выбора какой-то определённой ссылки или
        группы ссылок.
      </p>
      <p>
        # ✅ Сработает, .list-item это коллекция соседей с общим родителем
        .list-item:структурный-псевдокласс {} <br />
        # ❌ Не сработает, .list-link это не коллекция соседей, у них нет общего
        родителя .list-link:структурный-псевдокласс {}
      </p>
    </div>
    <!-- ================= /  Структурные псевдоклассы ============ -->

    <br />
    <!-- ================= Псевдоклассы :first-child и :last-child ============ -->
    <h3>Псевдоклассы :first-child и :last-child</h3>
    <p>
      Позволяют выбрать первый или последний элемент в коллекции соседей.
      Например, если каждому элементу списка задать нижний отступ, то он будет и
      у последнего. Крайнюю геометрию необходимо обязательно чистить, потому что
      такие оступы могут неочевидно выпадать или расширять родителя.
    </p>
    <div>
      <ul class="list">
        <li class="list-item">HTML</li>
        <li class="list-item">CSS</li>
        <li class="list-item">JavaScript</li>
        <li class="list-item">React</li>
      </ul>
    </div>
    <div>
      <p>
        Псевдокласс :last-child выбирает последний элемент в коллекции соседей.
      </p>
      <img src="./images/1-last-child.png" width="400" alt="" />
      <p>
        .list-item { <br />
        margin-bottom: 12px; <br />
        } <br />
        .list-item:last-child { <br />
        margin-bottom: 0; <br />
        }
      </p>
      <p>
        Аналогично работает :first-child, применяя стили к первому элементу в
        коллекции соседей. Например, когда нужно задать верхний отступ всем
        элементам кроме первого.
      </p>
      <img src="./images/2-first-child.png" width="400" alt="" />

      <p>
        .list-item { <br />
        margin-top: 12px; <br />
        } <br />

        .list-item:first-child { <br />
        margin-top: 0; <br />
        }
      </p>
    </div>

    <!-- ==================== :not(selector) =============== -->
    <div>
      <h3>Псевдокласс :not(selector)</h3>

      <p>
        Позволяет выбрать все элементы, которые не подходят под критерий -
        простой селектор записанный в скобках. Простой селектор это
        универсальный селектор, селектор типа, идентификатора, атрибута, класса
        или псевдокласса. Правило применения нижнего отступа ко всем элементам
        кроме последнего можно записать так.
      </p>
      <p>
        Читается как: применить стили ко всем элементам с классом list-item,
        <br />
        которые не являются последним элементом в коллекции соседей.
        <br />
        <br />
        .list-item:not(:last-child) { <br />
        margin-bottom: 12px; <br />
        }
      </p>
    </div>
    <br />
    <!-- ==================== / :not(selector) =============== -->
    <div>
      <!-- ==================== Псевдокласс :nth-child(an+b) =============== -->
      <h3>Псевдокласс :nth-child(an+b)</h3>
      <p>
        Позволяет выбрать все элементы, которые не подходят под критерий -
        простой селектор записанный в скобках. Простой селектор это
        универсальный селектор, селектор типа, идентификатора, атрибута, класса
        или псевдокласса. Правило применения нижнего отступа ко всем элементам
        кроме последнего можно записать так.
      </p>
      <p>
        Читается как: применить стили ко всем элементам с классом list-item,
        которые не являются последним элементом в коллекции соседей.
      </p>
      <p>
        .list-item:not(:last-child) { <br />
        margin-bottom: 12px; <br />
        }
      </p>
    </div>
    <!-- ==================== / :nth-child(an+b) =============== -->

    <!-- ==================== Псевдокласс :nth-child(an+b) =============== -->
    <div>
      <h3>Псевдокласс :nth-child(an+b)</h3>
      <p>
        Выбирает элементы в коллекции соседей по номеру указанному в скобках,
        при помощи цикла an+b, который позволяет задать правило для
        последовательности элементов.
      </p>
      <p>
        a - период цикла. Произвольное число. <br />
        n - счётчик цикла. Начинается с нуля и увеличивается на единицу на
        каждой итерации. <br />
        b - смещение. Произвольное число. <br />
        Например, если a = 2, а b = 1, то an+b = 2n+1. Эта формула выберет все
        нечётные элементы.
      </p>
      <p>
        # При n = 0 <br />
        2 * 0 + 1 = 1 <br />
        <br />
        # При n = 1 <br />
        2 * 1 + 1 = 3 <br />
        <br />
        # При n = 2 <br />
        2 * 2 + 1 = 5 <br />
        <br />
        # И так далее для n = 3, n = 4 ...
      </p>
      <p>
        Создадим разметку списка из десяти элементов и будем изменять цвет их
        фона.
      </p>
      <ul class="list">
        <li class="list-item">1</li>
        <li class="list-item">2</li>
        <li class="list-item">3</li>
        <li class="list-item">4</li>
        <li class="list-item">5</li>
        <li class="list-item">6</li>
        <li class="list-item">7</li>
        <li class="list-item">8</li>
        <li class="list-item">9</li>
        <li class="list-item">10</li>
      </ul>
      <h3>N-й элемент</h3>
      <p>
        В самом простом случае можно передать буквально номер элемента
        коллекции. То есть a = 0, а значение b это произвольное число - номер
        элемента коллекции. Тогда при любом n, формула будет 0 * n + b, или
        просто b.
      </p>
      <img src="./images/3-nth-5.png" width="400" alt="" />
      <p>
        .list-item:nth-child(5) { <br />
        background-color: orange; <br />
        }
      </p>
      <h4>Чётные и нечётные элементы</h4>
      <p>
        Для выбора всех чётных элементов можно использовать формулу 2n или её
        псевдоним - значение even, зарезервированное слово.
      </p>
      <img src="/images/4-nth-even.png" width="400" alt="" />
      <p>
        .list-item:nth-child(2n) { <br />
        background-color: orange; <br />
        } <br />
        <br />
        <b>Аналогично используя псевдоним</b> <br />
        .list-item:nth-child(even) { <br />
        background-color: orange; <br />
        }
      </p>
      <p>
        Для выбора нечётных элементов можно использовать формулу 2n + 1 или её
        псевдоним - значение odd, зарезервированное слово.
      </p>
      <img src="/images/5-nth-odd.png" width="400" alt="" />
      <p>
        .list-item:nth-child(2n + 1) { <br />
        background-color: orange; <br />
        } <br />
        <br />

        <b>Аналогично используя псевдоним</b> <br />
        .list-item:nth-child(odd) { <br />
        background-color: orange; <br />
        } <br />
      </p>
      <h3>От N-го элемента</h3>
      <p>
        Если задать a = 1, то результирующая формула n + b позволяет выбрать все
        элементы начиная с элемента под номером b. Например, для того, чтобы
        выбрать все элементы с шестого и дальше (то есть кроме первых пяти),
        используем формулу n + 6.
      </p>
      <img src="/images/6-nth-last.png" width="400" alt="" />

      <p>
        .list-item:nth-child(n + 6) { <br />
        background-color: orange; <br />
        } <br />
      </p>
      <h3>До N-го элемента</h3>
      <p>
        Если задать a = -1, то результирующая формула -n + b позволяет выбрать
        все элементы начиная с первого и до элемента под номером b. Например,
        для того чтобы выбрать первые пять элементов используем формулу -n + 5.
      </p>
      <p>
        .list-item:nth-child(-n + 5) { <br />
        background-color: orange; <br />
        } <br />
      </p>
      <h3>Каждый N-й элемент</h3>
      <p>
        Например, для того, чтобы выбрать каждый 3-й элемент начиная с первого,
        используем цикл an+b, в котором a = 3, а смещение b = 1.
      </p>
      <img src="/images/8-nth-every.png" width="400" alt="" />

      <p>
        .list-item:nth-child(3n + 1) { <br />
        background-color: orange; <br />
        } <br />
      </p>
    </div>
    <!-- ==================== / :nth-child(an+b) =============== -->

    <!-- ================ пример для закрепления =============  -->
    <p>
      <b> Несколько примеров для закрепления.</b> <br />
      3n + 2 - каждый третий элемент начиная со 2-го, то есть элементы 2, 5, 8 и
      т. д. <br />
      2n + 4 - каждый второй элемент начиная с 4-го, то есть элементы 4, 6, 8 и
      т. д. <br />
      4n + 5 - каждый четвёртый элемент начиная с 5-го, то есть элементы 5, 9,
      13 и т. д.
    </p>
    <h3>Псевдокласс :nth-last-child(an+b)</h3>
    <p>
      Аналог :nth-child() c отличием в том, что отсчёт ведётся с конца коллекции
      (последнего элемента).
    </p>
    <h4>N-й элемент</h4>
    <p>
      Выберем 3-й элемент с конца, то есть 8-й, потому что всего 10-ть
      элементов. Если бы всего было 20-ть элементов, тогда был бы выбран 18-й и
      т. д.
    </p>
    <img src="/images/9-nth-last-3.png" width="400" alt="" />
    <p>
      .list-item:nth-last-child(3) { <br />
      background-color: orange; <br />
      }
    </p>

    <h4>До N-го элемента</h4>
    <p>
      Чтобы выбрать несколько последних элементов в коллекции, используется
      формула -n + b, где b это количество выбираемых элементов. Например, при b
      = 3 будут выбраны только последние три элемента.
    </p>
    <img width="400" src="/images/10-nth-last-3.png" alt="" />
    <p>
      .list-item:nth-last-child(-n + 3) { <br />
      background-color: orange; <br />
      }
    </p>
    <!-- ================= / примеры =============== -->

    <!-- ==================== Дополнительные псевдоклассы ============ -->
    <h3>Дополнительные псевдоклассы</h3>
    <p>
      :first-of-type - выбирает первый селектор данного типа. <br />
      :last-of-type - выбирает последний селектор данного типа. <br />
      :only-of-type - выбирает элемент, который является единственным ребёнком
      такого типа в коллекции соседей. <br />
      :nth-of-type(an+b) - выбирает заданный в скобках номер селектора используя
      формулу an+b. <br />
      :nth-last-of-type(an+b) - аналог <br />
      :nth-of-type() с отличием в том, что отсчёт ведётся с конца колекции
      (последнего элемента). <br />
      :only-child - выбирает элемент, который является единственным ребёнком с
      таким селектором в коллекции соседей.<br />
      :empty - выбирает пустые элементы, то есть без потомков и текста.
    </p>
  </body>
</html>
